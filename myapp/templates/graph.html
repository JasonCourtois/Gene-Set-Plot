<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    <div id="plot-container">
      <script>
        // Main peices of data for all points
        const dataKeys = [
          "X",
          "Y",
          "qValue",
          "setName",
          "setSize",
          "molecules",
          "color",
          "pointNumber",
        ];

        const myPlot = document.getElementById("plot-container"); // Get refrence to where graph will be drawn
        const spinnerOverlay =
          window.parent.document.getElementById("loading-spinner");

        // Draw initial graph
        async function main() {
          let settings = getLocalStorage("settings");

          if (getLocalStorage("data") === null) {
            showSpinner();
            // Check if data exists, if not then get it, then draw graph
            try {
              await getUmapData(settings["umap"]);
            } catch (error) {
              hideSpinner();
              throw error;
              return;
            }
            hideSpinner();
          }

          graph();
          let mainDisplay = document.getElementsByClassName("user-select-none");
          mainDisplay[0].style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)"; // Add box shadow around graph to make it pop
        }

        // Draws graph based on current data stored in local storage key data and settings
        function graph() {
          let settings = getLocalStorage("settings"); // Getting resources from local storage
          let fullGraphData = getLocalStorage("data");
          let camera = getLocalStorage("camera");

          let displayedGraphData = {}; // Create Object to store data used for output

          dataKeys.forEach((key) => {
            displayedGraphData[key] = [];
          });

          let numberOfPoitns = fullGraphData["X"].length; // Get number of points, could have used any key here as they are all the same size

          for (let i = 0; i < numberOfPoitns; i++) {
            // Loop through full graph data, ignoring anything below cuttoff and adding the rest
            let belowMaximum =
              fullGraphData["qValue"][i] <= settings["q-value-maximum"];
            let aboveMinimum =
              fullGraphData["qValue"][i] >= settings["q-value-minimum"];
            if (belowMaximum && aboveMinimum) {
              dataKeys.forEach((key) => {
                displayedGraphData[key].push(fullGraphData[key][i]);
              });
            }
          }

          let trace = makeTrace(displayedGraphData, settings); // Create a plotly trace, this contians all data for each point on graph based on displayedGraphData

          let layout = {
            // Define layout properties of graoh
            title: "Click Here To Set Title",
            hovermode: "closest",
            xaxis: {
              title: "UMAP-1",
            },
            yaxis: {
              title: "UMAP-2",
            },
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };

          let config = {
            // Allow the annotations to be editable and disable default doubleclick as it causes zooming in to not work
            edits: {
              annotationTail: true,
              annotationText: true,
              titleText: true,
            },
            doubleClick: false,
          };

          if (camera) {
            // If camera settings exist, apply them here
            layout.xaxis = camera["xaxis"];
            layout.yaxis = camera["yaxis"];
            Plotly.newPlot("plot-container", [trace], layout, config);
          } else {
            // If they dont exist, create them using fullGraphData (this includes points above cutoff)
            Plotly.newPlot(
              "plot-container",
              [makeTrace(fullGraphData, settings)],
              layout,
              config
            );

            camera = {
              // Set camera to show all points in full graph by manually setting range
              xaxis: {
                title: "UMAP-1",
                autorange: false,
                range: myPlot.layout.xaxis.range,
              },
              yaxis: {
                title: "UMAP-2",
                autorange: false,
                range: myPlot.layout.yaxis.range,
              },
            };

            setLocalStorage("camera", camera); // Save and apply settings
            layout.xaxis = camera.xaxis;
            layout.yaxis = camera.yaxis;
            Plotly.newPlot("plot-container", [trace], layout, config);
          }

          // Handles selecting and unselecting data
          myPlot.on("plotly_click", function (event) {
            selectPoint(event, true);
          });

          // Handles select events with box select and lasso select
          myPlot.on("plotly_selected", function (event) {
            selectPoint(event, false);
          });

          // handles double clicking to zoom out
          myPlot.on("plotly_doubleclick", () => {
            camera = getLocalStorage("camera");
            Plotly.relayout("plot-container", {
              xaxis: camera["xaxis"],
              yaxis: camera["yaxis"],
            });
          });
        }

        // Get new graph data from UMAP on backend
        function getUmapData(umapSettings) {
          return new Promise((resolve, reject) => {
            let fileData = localStorage.getItem("rawFile");
            const csrftoken = getCookie("csrftoken");
            fetch("/read-output/" + umapSettings, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": csrftoken,
              },
              body: JSON.stringify({ file: fileData }),
            })
              .then((response) => response.json())
              .then((data) => {
                localStorage.removeItem("camera");
                // Object to store arrays
                let dataStorage = {};

                dataKeys.forEach((key) => {
                  dataStorage[key] = [];
                });

                for (let i = 0; i < data.length; i++) {
                  dataKeys.forEach((key) => {
                    if (key === "color") {
                      dataStorage["color"].push("white");
                    } else if (key === "pointNumber") {
                      dataStorage["pointNumber"].push(i);
                    } else {
                      dataStorage[key].push(data[i][key]);
                    }
                  });
                }

                // Store the entire data object in localStorage as JSON string
                setLocalStorage("data", dataStorage);
                resolve();
              })
              .catch((error) => {
                console.log(error);
                reject(error);
              });
          });
        }

        // When settings are changed, apply them
        window.addEventListener("storage", function (e) {
          if (e.key === "settings") {
            let selected = getLocalStorage("selected");
            let graph_data = getLocalStorage("data");
            let settings = getLocalStorage("settings");
            let pointNumber;

            // If umap settings changed, calculate umap again. Otherwise redraw graph
            if (settings["umapChange"]) {
              applyUmapChange(settings["umap"]);
            } else {
              if (selected === null) {
                selected = [];
              }

              // Update selected point colors
              for (let i = 0; i < selected.length; i++) {
                pointNumber = selected[i]["pointNumber"];
                graph_data["color"][pointNumber] = settings["selected-color"];
              }
              setLocalStorage("data", graph_data);
              graph();
            }
          }
        });

        async function applyUmapChange(umapSettings) {
          showSpinner();
          await getUmapData(umapSettings);
          hideSpinner();
          graph();
          clearSelected();
        }

        // Resize window on size change
        window.onresize = function () {
          let update = {
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };
          Plotly.relayout("plot-container", update);
        };

        function makeTrace(data, settings) {
          let size = getSize(data["setSize"], settings);

          let outlineWidth = data["color"].map((color) => {
            if (color === "white") {
              return 1;
            } else {
              return 2;
            }
          });

          let trace = {
            x: data["X"],
            y: data["Y"],
            mode: "markers",
            type: "scatter",
            text: data["setName"],
            customdata: data["qValue"].map((qValue, index) => [
              qValue,
              data["pointNumber"][index],
            ]),
            hovertemplate:
              "Name: %{text}<br>Q-Value: %{customdata[0]}<extra></extra>", // Format hover text
            marker: {
              color: data["qValue"],
              colorscale: [
                [0.0, settings["significant-color"]],
                [1.0, settings["insignificant-color"]],
              ],
              colorbar: {
                title: {
                  text: "Q-Value",
                  side: "right",
                },
              },
              cmax: settings["q-value-maximum"],
              cmin: settings["q-value-minimum"],
              size: size,
              opacity: 1.0,
              line: {
                width: outlineWidth,
                color: data["color"],
              },
            },
          };
          return trace;
        }

        function selectPoint(event, allowUnselect) {
          let selected = getLocalStorage("selected"); // Get needed data from local storage
          let fullGraphData = getLocalStorage("data");
          let settings = getLocalStorage("settings");
          if (selected === null) {
            selected = [];
          }

          if (event === undefined || event.points.length === 0) {
            return;
          }

          let firstPoint = event.points[0]; // Get the point that was clicked
          let curveNumber = firstPoint.curveNumber; // Get point number, curve number of graph, and make list of colors
          let borderColor = firstPoint.data.marker.line.color.slice();
          let pointColors = firstPoint.data.marker.color.slice();
          let outlineWidth = firstPoint.data.marker.line.width.slice();
          let size = firstPoint.data.marker.size.slice();

          let unselect = false; // Assume point isn't being unselected

          for (let i = 0; i < event.points.length; i++) {
            let pointNumber = event.points[i].pointNumber;
            let fullDataPointNumber = event.points[i].customdata[1];

            if (
              fullGraphData["color"][fullDataPointNumber] ===
                settings["selected-color"] &&
              allowUnselect // If the point is already selected (color is highlighted)
            ) {
              fullGraphData["color"][fullDataPointNumber] = "white";
              borderColor[pointNumber] = "white";
              outlineWidth[pointNumber] = 1;
              unselect = true;
            } else {
              borderColor[pointNumber] = settings["selected-color"];
              fullGraphData["color"][fullDataPointNumber] =
                settings["selected-color"];
              outlineWidth[pointNumber] = 2;
            }

            let selectedPoint = {
              pointNumber: fullDataPointNumber,
              qValue: fullGraphData["qValue"][fullDataPointNumber],
              molecules: fullGraphData["molecules"][fullDataPointNumber],
              setName: fullGraphData["setName"][fullDataPointNumber],
            };

            if (unselect && allowUnselect) {
              for (let i = 0; i < selected.length; i++) {
                if (selected[i]["pointNumber"] === fullDataPointNumber) {
                  selected.splice(i, 1);
                }
              }
            } else if (
              !selected.some(
                (obj) => obj["pointNumber"] === fullDataPointNumber
              )
            ) {
              selected.push(selectedPoint);
            }
          }

          setLocalStorage("data", fullGraphData);

          let update = {
            marker: {
              color: pointColors,
              colorbar: {
                title: {
                  text: "Q-Value",
                },
              },
              colorscale: [
                [0.0, settings["significant-color"]],
                [1.0, settings["insignificant-color"]],
              ],
              colorbar: {
                title: {
                  text: "Q-Value",
                  side: "right",
                },
              },
              cmax: settings["q-value-maximum"],
              cmin: settings["q-value-minimum"],
              size: size,
              opacity: 1.0,
              line: {
                width: outlineWidth,
                color: borderColor,
              },
            },
          };

          setLocalStorage("selected", selected);
          Plotly.restyle("plot-container", update, [curveNumber]);
        }

        // Clear out selected items
        function clearSelected() {
          let fullGraphData = getLocalStorage("data");
          let selected_points = getLocalStorage("selected");
          if (selected_points === null) {
            selected_points = [];
          }
          for (let i = 0; i < selected_points.length; i++) {
            point_number = selected_points[i]["pointNumber"];
            fullGraphData["color"][point_number] = "white";
          }
          localStorage.setItem("selected", "[]");
          setLocalStorage("data", fullGraphData);
          graph();
        }

        function toggleLabels() {
          let data = document.getElementById("plot-container").data[0];
          let fullData = getLocalStorage("data");
          let annotations = [];

          if (
            myPlot.layout.annotations !== undefined &&
            myPlot.layout.annotations.length !== 0
          ) {
            let layout = {
              annotations: annotations,
            };
            Plotly.relayout("plot-container", layout);
            return;
          }
          for (let i = 0; i < data["x"].length; i++) {
            let annotation = {
              x: data["x"][i],
              y: data["y"][i],
              text: fullData["setName"][data["customdata"][i][1]],
              showarrow: true,
              arrowhead: 0,
              ax: data["x"][i],
              ay: data["y"][i] + 0.5,
              axref: "x",
              ayref: "y",
              visible: true,
              arrowwidth: 0.7,
              font: {
                size: 13,
              },
            };
            let radius = 3;
            let attemptsWithCurrentRadius = 0;
            annotations.push(annotation);
            while (overlapping(annotations[i], annotations)) {
              annotations[i].ay =
                annotations[i].y +
                radius *
                  Math.sin(
                    Math.PI / 2 - (Math.PI / 7) * attemptsWithCurrentRadius
                  );
              annotations[i].ax =
                annotations[i].x +
                radius *
                  Math.cos(
                    Math.PI / 2 - (Math.PI / 7) * attemptsWithCurrentRadius
                  );
              attemptsWithCurrentRadius += 1;
              if (attemptsWithCurrentRadius >= 13) {
                radius += 0.2;
                attemptsWithCurrentRadius = 0;
              }
            }
          }

          let layout = {
            annotations: annotations,
          };
          Plotly.relayout("plot-container", layout);
        }

        function overlapping(annotation, annotations) {
          let yRange = 0.3;
          let xRange = 1.5;
          let overlapOnY = false;
          let overlapOnX = false;

          for (let i = 0; i < annotations.length - 1; i++) {
            overlapOnY = checkOverlapOnAxis(
              annotation.ay,
              annotations[i].ay,
              yRange
            );
            overlapOnX = checkOverlapOnAxis(
              annotation.ax,
              annotations[i].ax,
              xRange
            );
            if (overlapOnY && overlapOnX) {
              return true;
            }
          }
          return false;
        }

        function checkOverlapOnAxis(first, second, range) {
          return first > second - range && first < second + range;
        }

        function getSize(sizes, settings) {
          if (settings["fixed-size"]) {
            return settings["fixed-size-input"];
          }

          let minInput = sizes[0];
          let maxInput = sizes[0];
          let minOutput = parseFloat(settings["dynamic-size-minimum"]);
          let maxOutput = parseFloat(settings["dynamic-size-maximum"]);

          for (let i = 1; i < sizes.length; i++) {
            if (sizes[i] < minInput) {
              minInput = sizes[i];
            }
            if (sizes[i] > maxInput) {
              maxInput = sizes[i];
            }
          }

          let normalizedSizes = [];

          let scale = (maxOutput - minOutput) / (maxInput - minInput);

          for (let i = 0; i < sizes.length; i++) {
            normalizedSizes.push(minOutput + (sizes[i] - minInput) * scale);
          }

          return normalizedSizes;
        }

        function getLocalStorage(key) {
          return JSON.parse(localStorage.getItem(key));
        }

        function setLocalStorage(key, value) {
          localStorage.setItem(key, JSON.stringify(value));
        }

        function showSpinner() {
          spinnerOverlay.style.display = "flex";
        }

        function hideSpinner() {
          spinnerOverlay.style.display = "none";
        }

        // Function to get CSRF token
        function getCookie(name) {
          let cookieValue = null;
          if (document.cookie && document.cookie !== "") {
            const cookies = document.cookie.split(";");
            for (let i = 0; i < cookies.length; i++) {
              const cookie = cookies[i].trim();
              if (cookie.substring(0, name.length + 1) === name + "=") {
                cookieValue = decodeURIComponent(
                  cookie.substring(name.length + 1)
                );
                break;
              }
            }
          }
          return cookieValue;
        }
      </script>
    </div>
  </body>
</html>
