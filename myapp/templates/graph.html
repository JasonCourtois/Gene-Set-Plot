<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    <div id="plot-container">
      <script>
        /*
          Local Storage guide:
          key                 description
          data                Data is a dictonary with string keys X, Y, color, molecules, qValue, setName, and setSize.
                              The values of each of these keys is a list of size n representhing the corresponding value for the nth
                              gene set. So for example data["X"][23] is the x position of the 23 gene set on the graph

          selected            This is a list of 0 to 2 items. At each index is a dictonary with keys pointNumber, qValue, setName, and molecules.
                              Here, the item at selected[0] contains all the information on the first selected point, and selected[1] contains
                              the info for the second point. So if you needed the qVaule of point 1, you could do selectes[0]["qValue"].

          settings            This is a dictonary contianing.. finish when settings is done

        */
        const keys = ["X", "Y", "qValue", "setName", "setSize", "molecules"];

        main();

        // Draw initial graph
        async function main() {
          if (getLocalStorage("data") === null) {
            await getUmapData("");
          }
          graph();
          // Add box shadow around graph to make it pop
          let mainDisplay = document.getElementsByClassName("user-select-none");
          mainDisplay[0].style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)";
        }

        // Draws graph based on current data stored in local storage key data and settings
        function graph() {
          let settings = getLocalStorage("settings");
          let full_graph_data = getLocalStorage("data");
          let graph_data = {};
          let camera = getLocalStorage("camera");
          let selected = getLocalStorage("selected");
          var myPlot = document.getElementById("plot-container");
          let annotations = getLocalStorage("annotations");

          keys.forEach((key) => {
            graph_data[key] = [];
          });

          graph_data["color"] = [];
          graph_data["pointNumber"] = [];

          for (let i = 0; i < full_graph_data["X"].length; i++) {
            if (full_graph_data["qValue"][i] <= settings["cutoff"]) {
              keys.forEach((key) => {
                graph_data[key].push(full_graph_data[key][i]);
              });
              graph_data["color"].push(full_graph_data["color"][i]);
              graph_data["pointNumber"].push(i);
            } else {
              annotations[i].visible = false;
            }
          }

          setLocalStorage(annotations);

          // Define the plotly.js scatter plot
          var trace = makeTrace(graph_data, settings);

          var layout = {
            title: "UMAP projection of the Gene dataset",
            hovermode: "closest",
            xaxis: {
              title: "X",
            },
            yaxis: {
              title: "Y",
            },
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };

          let config = {
            edits: {
              annotationTail: true,
              annotationText: true,
              axisTitleText: true,
              colorbarTitleText: true,
            },
          };

          layout.annotations = annotations;

          if (camera) {
            layout.xaxis = camera["xaxis"];
            layout.yaxis = camera["yaxis"];
            Plotly.newPlot("plot-container", [trace], layout, config);
          } else {
            Plotly.newPlot(
              "plot-container",
              [makeTrace(full_graph_data, settings)],
              layout,
              config
            );
            camera = {
              xaxis: {
                title: "X",
                autorange: false,
                range: myPlot.layout.xaxis.range,
              },
              yaxis: {
                title: "Y",
                autorange: false,
                range: myPlot.layout.yaxis.range,
              },
            };
            setLocalStorage("camera", camera);
            layout.xaxis = camera.xaxis;
            layout.yaxis = camera.yaxis;
            Plotly.newPlot("plot-container", [trace], layout, config);
          }

          // Handles selecting and unselecting data

          myPlot.on("plotly_relayout", function (data) {
            setLocalStorage("annotations", myPlot.layout.annotations);
          });

          myPlot.on("plotly_click", function (data) {
            let selected = getLocalStorage("selected");
            settings = getLocalStorage("settings");
            if (selected === null) {
              selected = [];
            }

            var pointNumber = data.points[0].pointNumber;

            let unselect = false;

            if (
              full_graph_data["color"][pointNumber] ===
              settings["selectedColor"]
            ) {
              let normalColor = full_graph_data["qValue"][pointNumber];
              full_graph_data["color"][pointNumber] = normalColor;
              unselect = true;
            } else if (selected.length >= 2) {
              return;
            } else {
              full_graph_data["color"][pointNumber] = settings["selectedColor"];
            }

            setLocalStorage("data", full_graph_data);

            let selectedPoint = {
              pointNumber: pointNumber,
              qValue: full_graph_data["qValue"][pointNumber],
              molecules: full_graph_data["molecules"][pointNumber],
              setName: full_graph_data["setName"][pointNumber],
            };

            if (unselect) {
              for (let i = 0; i < selected.length; i++) {
                if (selected[i]["pointNumber"] === pointNumber) {
                  selected.splice(i, 1);
                }
              }
            } else {
              selected.push(selectedPoint);
            }

            setLocalStorage("selected", selected);
            graph();
          });
        }

        // Get new graph data from UMAP on backedn
        function getUmapData(umapSettings) {
          return new Promise((resolve, reject) => {
            fetch("/read-output/" + umapSettings)
              .then((response) => response.json())
              .then((data) => {
                localStorage.removeItem("camera");
                // Object to store arrays
                let dataStorage = {};

                keys.forEach((key) => {
                  dataStorage[key] = [];
                });
                dataStorage["color"] = [];
                dataStorage["pointNumber"] = [];

                for (let i = 0; i < data.length; i++) {
                  keys.forEach((key) => {
                    dataStorage[key].push(data[i][key]);
                  });
                  dataStorage["color"].push(data[i]["qValue"]);
                  dataStorage["pointNumber"].push(i);
                }

                // Store the entire data object in localStorage as JSON string
                setLocalStorage("data", dataStorage);

                let annotations = [];

                for (let i = 0; i < dataStorage["X"].length; i++) {
                  let annotation = {
                    x: dataStorage["X"][i],
                    y: dataStorage["Y"][i],
                    xref: "x",
                    yref: "y",
                    text: dataStorage["setName"][i],
                    showarrow: true,
                    arrowhead: 0,
                    ax: 0,
                    ay: -40,
                    visible: false,
                    arrowwidth: 0.7,
                    font: {
                      size: 13,
                    },
                  };
                  annotations.push(annotation);
                }

                setLocalStorage("annotations", annotations);
                resolve();
              })
              .catch((error) => {
                console.log(error);
                reject(error);
              });
          });
          // Load the JSON data
        }

        // When settings are changed, apply them
        window.addEventListener("storage", function (e) {
          if (e.key === "settings") {
            let selected = getLocalStorage("selected");
            let graph_data = getLocalStorage("data");
            let settings = getLocalStorage("settings");
            let pointNumber;

            // If umap settings changed, calculate umap again. Otherwise redraw graph
            if (settings["umapChange"]) {
              applyUmapChange(settings["umap"]);
            } else {
              if (selected === null) {
                selected = [];
              }

              // Update selected point colors
              for (let i = 0; i < selected.length; i++) {
                pointNumber = selected[i]["pointNumber"];
                graph_data["color"][pointNumber] = settings["selectedColor"];
              }
              setLocalStorage("data", graph_data);
              graph();
            }
          }
        });

        async function applyUmapChange(umapSettings) {
          await getUmapData(umapSettings);
          graph();
          clearSelected();
        }

        // Resize window on size change
        window.onresize = function () {
          let update = {
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };
          Plotly.relayout("plot-container", update);
        };

        function makeTrace(data, settings) {
          var trace = {
            x: data["X"],
            y: data["Y"],
            mode: "markers",
            type: "scatter",
            customdata: data["qValue"].map((qValue, index) => [
              qValue,
              data["pointNumber"][index],
            ]),
            hovertemplate:
              "X: %{x}<br>Y: %{y}<br>qValue: %{customdata[0]}<extra></extra>", // Format hover text
            marker: {
              color: data["color"],
              colorscale: [
                [0.0, settings["pointEndColor"]],
                [1.0, settings["pointStartColor"]],
              ],
              colorbar: {
                title: {
                  text: "Q-Value",
                },
              },
              cmax: settings["colorscaleMax"],
              cmin: settings["colorscaleMin"],
              size: settings["pointSize"],
            },
          };
          return trace;
        }

        // Clear out selected items
        function clearSelected() {
          let graph_data = getLocalStorage("data");
          let selected_points = getLocalStorage("selected");
          if (selected_points === null) {
            selected_points = [];
          }
          for (let i = 0; i < selected_points.length; i++) {
            point_number = selected_points[i]["pointNumber"];
            qvalue = selected_points[i]["qValue"];
            graph_data["color"][point_number] = qvalue;
          }
          localStorage.setItem("selected", "[]");
          setLocalStorage("data", graph_data);
          graph();
        }

        let labelState = true;

        function toggleLabels() {
          let data =
            document.getElementById("plot-container").data[0].customdata;
          let annotations = getLocalStorage("annotations");
          for (let i = 0; i < data.length; i++) {
            annotations[data[i][1]].visible = labelState;
          }
          labelState = !labelState;
          setLocalStorage("annotations", annotations);
          graph();
        }

        function getLocalStorage(key) {
          return JSON.parse(localStorage.getItem(key));
        }

        function setLocalStorage(key, value) {
          localStorage.setItem(key, JSON.stringify(value));
        }
      </script>
    </div>
  </body>
</html>
