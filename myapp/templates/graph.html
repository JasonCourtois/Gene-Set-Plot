<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    <div id="plot-container">
      <script>
        /*
          Local Storage guide:
          key                 description
          data                Data is a dictonary with string keys X, Y, color, molecules, qValue, setName, and setSize.
                              The values of each of these keys is a list of size n representhing the corresponding value for the nth
                              gene set. So for example data["X"][23] is the x position of the 23 gene set on the graph

          selected            This is a list of 0 to 2 items. At each index is a dictonary with keys pointNumber, qValue, setName, and molecules.
                              Here, the item at selected[0] contains all the information on the first selected point, and selected[1] contains
                              the info for the second point. So if you needed the qVaule of point 1, you could do selectes[0]["qValue"].

          settings            This is a dictonary contianing.. finish when settings is done

        */

        // Main peices of data for all points
        const dataKeys = [
          "X",
          "Y",
          "qValue",
          "setName",
          "setSize",
          "molecules",
          "color",
          "pointNumber",
        ];

        const myPlot = document.getElementById("plot-container"); // Get refrence to where graph will be drawn

        // Entry Point
        main();

        // Draw initial graph
        async function main() {
          if (getLocalStorage("data") === null) {
            // Check if data exists, if not then get it, then draw graph
            await getUmapData("");
          }
          graph();

          let mainDisplay = document.getElementsByClassName("user-select-none");
          mainDisplay[0].style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)"; // Add box shadow around graph to make it pop
        }

        // Draws graph based on current data stored in local storage key data and settings
        function graph() {
          let settings = getLocalStorage("settings"); // Getting resources from local storage
          let fullGraphData = getLocalStorage("data");
          let camera = getLocalStorage("camera");

          let displayedGraphData = {}; // Create Object to store data used for output

          dataKeys.forEach((key) => {
            displayedGraphData[key] = [];
          });

          let numberOfPoitns = fullGraphData["X"].length; // Get number of points, could have used any key here as they are all the same size

          for (let i = 0; i < numberOfPoitns; i++) {
            // Loop through full graph data, ignoring anything below cuttoff and adding the rest
            let belowCutoff = fullGraphData["qValue"][i] <= settings["cutoff"];
            if (belowCutoff) {
              dataKeys.forEach((key) => {
                displayedGraphData[key].push(fullGraphData[key][i]);
              });
            }
          }

          let trace = makeTrace(displayedGraphData, settings); // Create a plotly trace, this contians all data for each point on graph based on displayedGraphData

          let layout = {
            // Define layout properties of graoh
            title: "UMAP projection of the Gene dataset",
            hovermode: "closest",
            xaxis: {
              title: "UMAP-1",
            },
            yaxis: {
              title: "UMAP-2",
            },
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };

          let config = {
            // Allow the annotations to be editable and disable default doubleclick as it causes zooming in to not work
            edits: {
              annotationTail: true,
              annotationText: true,
            },
            doubleClick: false,
          };

          if (camera) {
            // If camera settings exist, apply them here
            layout.xaxis = camera["xaxis"];
            layout.yaxis = camera["yaxis"];
            Plotly.newPlot("plot-container", [trace], layout, config);
          } else {
            // If they dont exist, create them using fullGraphData (this includes points above cutoff)
            Plotly.newPlot(
              "plot-container",
              [makeTrace(fullGraphData, settings)],
              layout,
              config
            );

            camera = {
              // Set camera to show all points in full graph by manually setting range
              xaxis: {
                title: "UMAP-1",
                autorange: false,
                range: myPlot.layout.xaxis.range,
              },
              yaxis: {
                title: "UMAP-2",
                autorange: false,
                range: myPlot.layout.yaxis.range,
              },
            };

            setLocalStorage("camera", camera); // Save and apply settings
            layout.xaxis = camera.xaxis;
            layout.yaxis = camera.yaxis;
            Plotly.newPlot("plot-container", [trace], layout, config);
          }

          // DEBUG for now
          myPlot.on("plotly_relayout", function (data) {
            //console.log(myPlot.layout.annotations);
          });
        }

        // Handles selecting and unselecting data
        myPlot.on("plotly_click", function (event) {
          let selected = getLocalStorage("selected"); // Get needed data from local storage
          let fullGraphData = getLocalStorage("data");
          let settings = getLocalStorage("settings");
          if (selected === null) {
            selected = [];
          }

          let point = event.points[0]; // Get the point that was clicked

          let curveNumber = point.curveNumber; // Get point number, curve number of graph, and make list of colors
          let colors = point.data.marker.color.slice();
          let pointNumber = point.pointNumber;

          console.log(colors);
          console.log(fullGraphData["color"]);

          let unselect = false; // Assume point isn't being unselected

          if (
            fullGraphData["color"][pointNumber] === settings["selectedColor"] // If the point is already selected (color is highlighted)
          ) {
            let normalColor = fullGraphData["qValue"][pointNumber]; // Get normal color and update the local storage data and new color array
            fullGraphData["color"][pointNumber] = normalColor;
            colors[pointNumber] = normalColor;
            unselect = true;
          } else {
            colors[pointNumber] = settings["selectedColor"];
            fullGraphData["color"][pointNumber] = settings["selectedColor"];
          }

          setLocalStorage("data", fullGraphData);

          let selectedPoint = {
            pointNumber: pointNumber,
            qValue: fullGraphData["qValue"][pointNumber],
            molecules: fullGraphData["molecules"][pointNumber],
            setName: fullGraphData["setName"][pointNumber],
          };

          if (unselect) {
            for (let i = 0; i < selected.length; i++) {
              if (selected[i]["pointNumber"] === pointNumber) {
                selected.splice(i, 1);
              }
            }
          } else {
            selected.push(selectedPoint);
          }

          let update = {
            marker: {
              color: colors,
              colorbar: {
                title: {
                  text: "Q-Value",
                },
              },
              colorscale: [
                [0.0, settings["pointEndColor"]],
                [1.0, settings["pointStartColor"]],
              ],
              colorbar: {
                title: {
                  text: "Q-Value",
                },
              },
              cmax: settings["colorscaleMax"],
              cmin: settings["colorscaleMin"],
              size: settings["pointSize"],
            },
          };

          setLocalStorage("selected", selected);
          Plotly.restyle("plot-container", update, [curveNumber]);
        });

        myPlot.on("plotly_doubleclick", () => {
          camera = getLocalStorage("camera");
          Plotly.relayout("plot-container", {
            xaxis: camera["xaxis"],
            yaxis: camera["yaxis"],
          });
        });

        // Get new graph data from UMAP on backend
        function getUmapData(umapSettings) {
          return new Promise((resolve, reject) => {
            fetch("/read-output/" + umapSettings)
              .then((response) => response.json())
              .then((data) => {
                localStorage.removeItem("camera");
                // Object to store arrays
                let dataStorage = {};

                dataKeys.forEach((key) => {
                  dataStorage[key] = [];
                });

                for (let i = 0; i < data.length; i++) {
                  dataKeys.forEach((key) => {
                    if (key === "color") {
                      dataStorage["color"].push(data[i]["qValue"]);
                    } else if (key === "pointNumber") {
                      dataStorage["pointNumber"].push(i);
                    } else {
                      dataStorage[key].push(data[i][key]);
                    }
                  });
                }

                // Store the entire data object in localStorage as JSON string
                setLocalStorage("data", dataStorage);
                resolve();
              })
              .catch((error) => {
                console.log(error);
                reject(error);
              });
          });
        }

        // When settings are changed, apply them
        window.addEventListener("storage", function (e) {
          if (e.key === "settings") {
            let selected = getLocalStorage("selected");
            let graph_data = getLocalStorage("data");
            let settings = getLocalStorage("settings");
            let pointNumber;

            // If umap settings changed, calculate umap again. Otherwise redraw graph
            if (settings["umapChange"]) {
              applyUmapChange(settings["umap"]);
            } else {
              if (selected === null) {
                selected = [];
              }

              // Update selected point colors
              for (let i = 0; i < selected.length; i++) {
                pointNumber = selected[i]["pointNumber"];
                graph_data["color"][pointNumber] = settings["selectedColor"];
              }
              setLocalStorage("data", graph_data);
              graph();
            }
          }
        });

        async function applyUmapChange(umapSettings) {
          await getUmapData(umapSettings);
          graph();
          clearSelected();
        }

        // Resize window on size change
        window.onresize = function () {
          let update = {
            height: Math.max(window.innerHeight - 50, 300),
            width: Math.max(window.innerWidth - 50, 300),
          };
          Plotly.relayout("plot-container", update);
        };

        function makeTrace(data, settings) {
          let trace = {
            x: data["X"],
            y: data["Y"],
            mode: "markers",
            type: "scatter",
            customdata: data["qValue"].map((qValue, index) => [
              qValue,
              data["pointNumber"][index],
            ]),
            hovertemplate:
              "X: %{x}<br>Y: %{y}<br>qValue: %{customdata[0]}<extra></extra>", // Format hover text
            marker: {
              color: data["color"],
              colorscale: [
                [0.0, settings["pointEndColor"]],
                [1.0, settings["pointStartColor"]],
              ],
              colorbar: {
                title: {
                  text: "Q-Value",
                },
              },
              cmax: settings["colorscaleMax"],
              cmin: settings["colorscaleMin"],
              size: settings["pointSize"],
            },
          };
          return trace;
        }

        // Clear out selected items
        function clearSelected() {
          let fullGraphData = getLocalStorage("data");
          let selected_points = getLocalStorage("selected");
          if (selected_points === null) {
            selected_points = [];
          }
          for (let i = 0; i < selected_points.length; i++) {
            point_number = selected_points[i]["pointNumber"];
            qvalue = selected_points[i]["qValue"];
            fullGraphData["color"][point_number] = qvalue;
          }
          localStorage.setItem("selected", "[]");
          setLocalStorage("data", fullGraphData);
          graph();
        }

        function toggleLabels() {
          let data = document.getElementById("plot-container").data[0];
          let fullData = getLocalStorage("data");
          let annotations = [];
          
          if (myPlot.layout.annotations !== undefined && myPlot.layout.annotations.length !== 0) {
            let layout = {
              annotations: annotations,
            };
            Plotly.relayout("plot-container", layout);
            return;
          }
          for (let i = 0; i < data["x"].length; i++) {
            let annotation = {
              x: data["x"][i],
              y: data["y"][i],
              text: fullData["setName"][data["customdata"][i][1]],
              showarrow: true,
              arrowhead: 0,
              ax: data["x"][i],
              ay: data["y"][i] + 0.5,
              axref: "x",
              ayref: "y",
              visible: true,
              arrowwidth: 0.7,
              font: {
                size: 13,
              },
            };
            let radius = 1;
            let attemptsWithCurrentRadius = 0;
            annotations.push(annotation);
            while (overlapping(annotations[i], annotations)) {
              annotations[i].ay =
                annotations[i].y +
                radius *
                  Math.sin(
                    Math.PI / 2 - (Math.PI / 7) * attemptsWithCurrentRadius
                  );
              annotations[i].ax =
                annotations[i].x +
                radius *
                  Math.cos(
                    Math.PI / 2 - (Math.PI / 7) * attemptsWithCurrentRadius
                  );
              attemptsWithCurrentRadius += 1;
              if (attemptsWithCurrentRadius >= 13) {
                radius += 0.2;
                attemptsWithCurrentRadius = 0;
              }
            }
          }

          let layout = {
            annotations: annotations,
          };
          Plotly.relayout("plot-container", layout);
        }

        function overlapping(annotation, annotations) {
          let yRange = 0.3;
          let xRange = 1.5;
          let overlapOnY = false;
          let overlapOnX = false;

          for (let i = 0; i < annotations.length - 1; i++) {
            overlapOnY = checkOverlapOnAxis(
              annotation.ay,
              annotations[i].ay,
              yRange
            );
            overlapOnX = checkOverlapOnAxis(
              annotation.ax,
              annotations[i].ax,
              xRange
            );
            if (overlapOnY && overlapOnX) {
              return true;
            }
          }
          return false;
        }

        function checkOverlapOnAxis(first, second, range) {
          return first > second - range && first < second + range;
        }

        function getLocalStorage(key) {
          return JSON.parse(localStorage.getItem(key));
        }

        function setLocalStorage(key, value) {
          localStorage.setItem(key, JSON.stringify(value));
        }
      </script>
    </div>
  </body>
</html>
